<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Laguna Sneca</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
      touch-action: none;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
  const BPM = 105;
  const STEPS_PER_BEAT = 4;
  const SECONDS_PER_STEP = 60 / (BPM * STEPS_PER_BEAT);
  const MUSIC_OFFSET = 0.20;

  // Detect touch device
  const IS_TOUCH =
    ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

  // Grid + stroke
  const CELL_SIZE    = IS_TOUCH ? 48 : 26;   // tweak if you like
  const STROKE_WIDTH = IS_TOUCH ? 3  : 2;    // outline thickness

  const SNAKE_COLOR      = "#88ff55";
  const SNAKE_HEAD_COLOR = "#a8ff75";
  const SNAKE_EYE_COLOR  = "#000000";
  const FOOD_COLOR       = "#ff6666";
  const FOOD_BORDER      = "#000000";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const bgImage = new Image();
  bgImage.src = "background.jpg";

  const titleLogo = new Image();
  titleLogo.src = "laguna-logo.png";

  const deathLogo = new Image();
  deathLogo.src = "you_died_from_hot_clean.png";

  const music = new Audio("loop.mp3");
  music.loop = true;
  music.preload = "auto";

  // death sound
  const deathSound = new Audio("death.wav");
  deathSound.preload = "auto";
  deathSound.volume = 1.0; // tweak if too loud

  let cols = 0;
  let rows = 0;

  let snake = [];
  let direction = { x: 1, y: 0 };
  let nextDirection = { x: 1, y: 0 };
  let food = { x: 0, y: 0 };
  let score = 0;

  // "title" | "playing" | "dead"
  let gameState = "title";

  let isPaused = true;
  let isDead = false;
  let musicStarted = false;
  let lastStepIndex = -1;
  let lastAudioTime = 0;

  // fallback internal clock (for devices where audio time doesn't advance)
  let manualClockStart = null;

  // touch / swipe
  let touchStartX = null;
  let touchStartY = null;
  let touchStartTime = 0;
  const SWIPE_THRESHOLD = 30;
  const SWIPE_MAX_TIME = 500;

  function resizeCanvasToImage() {
    const maxW = window.innerWidth;
    const maxH = window.innerHeight;

    const imgAspect = bgImage.width / bgImage.height;
    const winAspect = maxW / maxH;

    let cw, ch;
    if (winAspect > imgAspect) {
      ch = maxH;
      cw = ch * imgAspect;
    } else {
      cw = maxW;
      ch = cw / imgAspect;
    }

    canvas.width  = Math.floor(cw / CELL_SIZE) * CELL_SIZE;
    canvas.height = Math.floor(ch / CELL_SIZE) * CELL_SIZE;

    cols = canvas.width  / CELL_SIZE;
    rows = canvas.height / CELL_SIZE;
  }

  function initGame() {
    const startX = Math.floor(cols / 4);
    const startY = Math.floor(rows / 2);

    snake = [];
    for (let i = 0; i < 4; i++) {
      snake.push({ x: startX - i, y: startY });
    }

    direction = { x: 1, y: 0 };
    nextDirection = { x: 1, y: 0 };
    score = 0;

    gameState = "title";
    isPaused = true;
    isDead = false;
    musicStarted = false;
    lastStepIndex = -1;
    lastAudioTime = 0;
    manualClockStart = null;

    spawnFood();
  }

  function spawnFood() {
    while (true) {
      const fx = Math.floor(Math.random() * cols);
      const fy = Math.floor(Math.random() * rows);

      let onSnake = false;
      for (const seg of snake) {
        if (seg.x === fx && seg.y === fy) {
          onSnake = true;
          break;
        }
      }
      if (!onSnake) {
        food.x = fx;
        food.y = fy;
        return;
      }
    }
  }

  function startMusicIfNeeded() {
    if (!musicStarted) {
      music.currentTime = 0;
      music.play().catch(() => {});
      musicStarted = true;
      lastStepIndex = -1;
      lastAudioTime = 0;
      // reset manual clock; it will be re-set if needed
      manualClockStart = null;
    }
  }

  function startPlaying() {
    if (gameState !== "playing") {
      gameState = "playing";
    }
    isPaused = false;

    // start our fallback clock immediately
    if (manualClockStart === null) {
      manualClockStart = performance.now() / 1000;
    }

    startMusicIfNeeded();
  }

  function restartGame() {
    music.pause();
    music.currentTime = 0;
    musicStarted = false;
    lastStepIndex = -1;
    lastAudioTime = 0;
    manualClockStart = null;
    initGame();
  }

  function handleKey(e) {
    const key = e.key;

    if (key === "ArrowUp" && direction.y !== 1) {
      nextDirection = { x: 0, y: -1 };
      if (gameState === "title") startPlaying();
      else {
        startMusicIfNeeded();
        isPaused = false;
      }
    } else if (key === "ArrowDown" && direction.y !== -1) {
      nextDirection = { x: 0, y: 1 };
      if (gameState === "title") startPlaying();
      else {
        startMusicIfNeeded();
        isPaused = false;
      }
    } else if (key === "ArrowLeft" && direction.x !== 1) {
      nextDirection = { x: -1, y: 0 };
      if (gameState === "title") startPlaying();
      else {
        startMusicIfNeeded();
        isPaused = false;
      }
    } else if (key === "ArrowRight" && direction.x !== -1) {
      nextDirection = { x: 1, y: 0 };
      if (gameState === "title") startPlaying();
      else {
        startMusicIfNeeded();
        isPaused = false;
      }
    } else if (key === " " || key === "Spacebar") {
      if (gameState === "title") {
        startPlaying();
      } else if (gameState === "dead") {
        restartGame();
      } else {
        if (isPaused) {
          isPaused = false;
          startMusicIfNeeded();
          music.play().catch(() => {});
        } else {
          isPaused = true;
          music.pause();
        }
      }
    } else if (key === "r" || key === "R") {
      restartGame();
    }
  }

  document.addEventListener("keydown", handleKey);

  // touch controls

  function handleTouchSwipe(dx, dy) {
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    if (absX > absY) {
      if (dx > 0 && direction.x !== -1) {
        nextDirection = { x: 1, y: 0 };
      } else if (dx < 0 && direction.x !== 1) {
        nextDirection = { x: -1, y: 0 };
      }
    } else {
      if (dy > 0 && direction.y !== -1) {
        nextDirection = { x: 0, y: 1 };
      } else if (dy < 0 && direction.y !== 1) {
        nextDirection = { x: 0, y: -1 };
      }
    }

    if (gameState === "title") {
      startPlaying();
    } else if (gameState === "playing") {
      startMusicIfNeeded();
      isPaused = false;
    }
  }

  function handleTouchTap() {
    if (gameState === "title") {
      startPlaying();
    } else if (gameState === "dead") {
      restartGame();
    } else {
      if (isPaused) {
        isPaused = false;
        startMusicIfNeeded();
        music.play().catch(() => {});
      } else {
        isPaused = true;
        music.pause();
      }
    }
  }

  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    touchStartTime = Date.now();
  }, { passive: false });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    if (touchStartX === null || touchStartY === null) return;

    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dt = Date.now() - touchStartTime;

    if (dist >= SWIPE_THRESHOLD && dt <= SWIPE_MAX_TIME) {
      handleTouchSwipe(dx, dy);
    } else {
      handleTouchTap();
    }

    touchStartX = null;
    touchStartY = null;
  }, { passive: false });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
  }, { passive: false });

  // unified death handler
  function handleDeath() {
    if (isDead) return;
    isDead = true;
    isPaused = true;
    gameState = "dead";
    music.pause();

    // delay the sound slightly for cleaner impact
    setTimeout(() => {
      deathSound.currentTime = 0;
      deathSound.play().catch(() => {});
    }, 25);
  }

  // core game logic

  function moveSnakeOneStep() {
    direction = nextDirection;

    const head = snake[0];
    const newHead = {
      x: head.x + direction.x,
      y: head.y + direction.y
    };

    // wall collision
    if (newHead.x < 0 || newHead.x >= cols || newHead.y < 0 || newHead.y >= rows) {
      handleDeath();
      return;
    }

    // self collision
    for (const seg of snake) {
      if (seg.x === newHead.x && seg.y === newHead.y) {
        handleDeath();
        return;
      }
    }

    snake.unshift(newHead);

    if (newHead.x === food.x && newHead.y === food.y) {
      score++;
      spawnFood();
    } else {
      snake.pop();
    }
  }

  function updateFromMusic() {
    if (isPaused || isDead || gameState !== "playing") return;

    let t;
    let usingMusic = false;

    // prefer music time if it is actually advancing
    if (musicStarted && music.currentTime > 0.01) {
      t = music.currentTime;
      usingMusic = true;
    } else {
      // fallback to internal clock
      if (manualClockStart === null) {
        manualClockStart = performance.now() / 1000;
      }
      t = performance.now() / 1000 - manualClockStart;
    }

    // handle audio loop wrap when using music
    if (usingMusic) {
      if (t < lastAudioTime) {
        lastStepIndex = -1;
      }
      lastAudioTime = t;
    }

    if (t < MUSIC_OFFSET) return;

    const stepIndex = Math.floor((t - MUSIC_OFFSET) / SECONDS_PER_STEP);

    if (stepIndex <= lastStepIndex) return;

    const stepsToDo = Math.min(stepIndex - lastStepIndex, 4);

    for (let i = 0; i < stepsToDo; i++) {
      moveSnakeOneStep();
      if (isDead) break;
    }

    lastStepIndex = stepIndex;
  }

  function drawBackground() {
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  }

  function drawSnake() {
    ctx.lineWidth = STROKE_WIDTH;

    for (let i = 0; i < snake.length; i++) {
      const seg = snake[i];
      const x = seg.x * CELL_SIZE;
      const y = seg.y * CELL_SIZE;

      ctx.fillStyle   = i === 0 ? SNAKE_HEAD_COLOR : SNAKE_COLOR;
      ctx.strokeStyle = "#000000";
      ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
      ctx.strokeRect(x + 0.5, y + 0.5, CELL_SIZE - 1, CELL_SIZE - 1);

      if (i === 0) {
        ctx.fillStyle = SNAKE_EYE_COLOR;

        const eyeSize = Math.max(2, Math.floor(CELL_SIZE / 6));

        if (direction.x === 1) {
          ctx.fillRect(x + CELL_SIZE - 3 * eyeSize, y + eyeSize, eyeSize, eyeSize);
          ctx.fillRect(x + CELL_SIZE - 3 * eyeSize, y + 3 * eyeSize, eyeSize, eyeSize);
        } else if (direction.x === -1) {
          ctx.fillRect(x + 2 * eyeSize, y + eyeSize, eyeSize, eyeSize);
          ctx.fillRect(x + 2 * eyeSize, y + 3 * eyeSize, eyeSize, eyeSize);
        } else if (direction.y === 1) {
          ctx.fillRect(x + eyeSize, y + CELL_SIZE - 3 * eyeSize, eyeSize, eyeSize);
          ctx.fillRect(x + 3 * eyeSize, y + CELL_SIZE - 3 * eyeSize, eyeSize, eyeSize);
        } else {
          ctx.fillRect(x + eyeSize, y + 2 * eyeSize, eyeSize, eyeSize);
          ctx.fillRect(x + 3 * eyeSize, y + 2 * eyeSize, eyeSize, eyeSize);
        }
      }
    }
  }

  function drawFood() {
    const x = food.x * CELL_SIZE;
    const y = food.y * CELL_SIZE;

    ctx.fillStyle = FOOD_COLOR;
    ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);

    ctx.strokeStyle = FOOD_BORDER;
    ctx.lineWidth   = STROKE_WIDTH;       // same outline style as snake
    ctx.strokeRect(x + 0.5, y + 0.5, CELL_SIZE - 1, CELL_SIZE - 1);
  }

  function drawScore() {
    ctx.fillStyle = "black";
    ctx.font = "20px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Score: " + score, 5, 5);
  }

  function drawCenteredTextLines(lines, centerY, lineHeight, fontSize) {
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.font = `${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;

    const x = canvas.width / 2;
    const totalHeight = lineHeight * (lines.length - 1);
    const firstY = centerY - totalHeight / 2;

    lines.forEach((line, i) => {
      ctx.fillText(line, x, firstY + i * lineHeight);
    });

    ctx.textAlign = "left";
    ctx.textBaseline = "top";
  }

  function drawTitleOverlay() {
    if (titleLogo.complete && titleLogo.naturalWidth) {
      const maxLogoWidth  = canvas.width * 0.8;
      const maxLogoHeight = canvas.height * 0.35;

      const scale = Math.min(
        maxLogoWidth  / titleLogo.naturalWidth,
        maxLogoHeight / titleLogo.naturalHeight
      );

      const logoWidth  = titleLogo.naturalWidth  * scale;
      const logoHeight = titleLogo.naturalHeight * scale;

      const x = (canvas.width  - logoWidth)  / 2;
      const y = canvas.height * 0.22;

      ctx.drawImage(titleLogo, x, y, logoWidth, logoHeight);
    }

    drawCenteredTextLines(
      ["Press Space or Arrow key to start", "On mobile: swipe to move, tap to pause"],
      canvas.height * 0.75,
      28,
      20
    );
  }

  function drawDeathOverlay() {
    if (deathLogo.complete && deathLogo.naturalWidth) {
      const maxLogoWidth  = canvas.width * 0.9;
      const maxLogoHeight = canvas.height * 0.6;

      const scale = Math.min(
        maxLogoWidth  / deathLogo.naturalWidth,
        maxLogoHeight / deathLogo.naturalHeight
      );

      const logoWidth  = deathLogo.naturalWidth  * scale;
      const logoHeight = deathLogo.naturalHeight * scale;

      const x = (canvas.width  - logoWidth)  / 2;
      const y = (canvas.height - logoHeight) / 2;

      ctx.drawImage(deathLogo, x, y, logoWidth, logoHeight);
    } else {
      drawCenteredTextLines(
        ["You died!", "Press Space or R to restart"],
        canvas.height / 2,
        48,
        40
      );
    }
  }

  function gameLoop() {
    if (bgImage.complete) {
      drawBackground();
      updateFromMusic();
      drawFood();
      drawSnake();
      drawScore();

      if (gameState === "title") {
        drawTitleOverlay();
      } else if (gameState === "dead") {
        drawDeathOverlay();
      }
    }
    requestAnimationFrame(gameLoop);
  }

  bgImage.onload = () => {
    resizeCanvasToImage();
    initGame();
    gameLoop();
  };

  window.addEventListener("resize", () => {
    if (!bgImage.complete) return;
    resizeCanvasToImage();
    initGame();
  });
</script>
</body>
</html>
