<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Laguna Sneca – A Mini Game by Laguna Seca</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="game/laguna-logo.png" />

  <style>
    :root {
      --cabinet-bg: #1e1035;
      --cabinet-border: #130824;
      --button-blue: #00b7de;
      --button-pink: #ff3f86;
      --text-muted: #f1e9ff;
      --snake-body: #7dfb4a;
      --snake-head: #b8ff77;
      --food: #ff5a5a;
      --score-text: #000000;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text-muted);
      background: #f3c845 url("game/background.jpg") center center / cover fixed no-repeat;
    }

    .page-wrapper {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px 12px 32px;
    }

    /* Arcade cabinet shell */
    .cabinet {
      width: min(440px, 100%);
      background: var(--cabinet-bg);
      border-radius: 32px;
      box-shadow:
        0 26px 60px rgba(0, 0, 0, 0.65),
        0 0 0 6px rgba(0, 0, 0, 0.5);
      padding: 24px 20px 26px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 6px solid var(--cabinet-border);
    }

    .top-logo {
      width: 100%;
      max-width: 340px;
      display: block;
      margin: 0 auto 8px;
    }

    .subtitle {
      font-size: 0.7rem;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      text-align: center;
      margin-bottom: 18px;
      color: rgba(235, 223, 255, 0.85);
    }

    /* Screen frame */
    .screen-frame {
      width: 100%;
      background: #050006;
      border-radius: 18px;
      padding: 10px;
      box-shadow:
        inset 0 0 0 2px rgba(0, 0, 0, 0.7),
        0 16px 30px rgba(0, 0, 0, 0.75);
      margin-bottom: 18px;
    }

    /* Actual canvas – rectangular frame, 19:34 aspect */
    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 19 / 34;        /* keep ratio visually */
      border: 3px solid #000000;    /* rectangular frame */
      border-radius: 0;
      image-rendering: pixelated;
      background: #000000;
    }

    /* Buttons row */
    .button-row {
      display: flex;
      width: 100%;
      justify-content: center;
      gap: 18px;
      margin-bottom: 10px;
      margin-top: 2px;
    }

    .cta-button {
      flex: 1 1 0;
      border-radius: 999px;
      padding: 10px 0;
      border: none;
      font-weight: 700;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 0.8rem;
      cursor: pointer;
      box-shadow:
        0 6px 14px rgba(0, 0, 0, 0.7),
        0 0 0 2px rgba(0, 0, 0, 0.4);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out;
    }

    .cta-button.blue {
      background: var(--button-blue);
      color: #001018;
    }

    .cta-button.pink {
      background: var(--button-pink);
      color: #220013;
    }

    .cta-button:hover {
      transform: translateY(-1px);
      box-shadow:
        0 10px 18px rgba(0, 0, 0, 0.8),
        0 0 0 2px rgba(0, 0, 0, 0.5);
    }

    .cta-button:active {
      transform: translateY(1px);
      box-shadow:
        0 3px 8px rgba(0, 0, 0, 0.8),
        0 0 0 2px rgba(0, 0, 0, 0.6);
    }

    /* Footer text */
    .footer-text {
      width: 100%;
      text-align: center;
      font-size: 0.65rem;
      line-height: 1.4;
      color: rgba(240, 230, 255, 0.9);
    }

    .footer-text a {
      color: #ff5f9c;
      text-decoration: none;
    }

    .footer-text a:hover {
      text-decoration: underline;
    }

    @media (min-height: 900px) {
      .page-wrapper {
        padding-top: 40px;
        padding-bottom: 40px;
      }
    }
  </style>
</head>
<body>
  <div class="page-wrapper">
    <div class="cabinet">
      <img
        src="game/laguna-logo.png"
        alt="Laguna Sneca"
        class="top-logo"
        loading="lazy"
      />
      <div class="subtitle">A MINI GAME BY LAGUNA SECA</div>

      <div class="screen-frame">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div class="button-row">
        <button
          class="cta-button blue"
          onclick="window.open('https://lagunaseca70.bandcamp.com', '_blank')"
        >
          Bandcamp
        </button>
        <button
          class="cta-button pink"
          onclick="window.open('https://www.patreon.com/lagunaseca70', '_blank')"
        >
          Patreon
        </button>
      </div>

      <div class="footer-text">
        Game, music and design by Laguna Seca. Snake locked to 105&nbsp;BPM.<br />
        Contact:
        <a href="mailto:contact@lagunaseca70.com">contact@lagunaseca70.com</a>
      </div>
    </div>
  </div>

  <script>
    // ---------- CONFIG ----------
    const GRID_COLS = 19;
    const GRID_ROWS = 34;
    const TICK_MS = 140; // move speed; tune to taste vs 105 BPM

    const TILE_BG = "#000000";
    const SNAKE_BODY = getComputedStyle(document.documentElement)
      .getPropertyValue("--snake-body")
      .trim();
    const SNAKE_HEAD = getComputedStyle(document.documentElement)
      .getPropertyValue("--snake-head")
      .trim();
    const FOOD_COLOR = getComputedStyle(document.documentElement)
      .getPropertyValue("--food")
      .trim();
    const SCORE_COLOR = getComputedStyle(document.documentElement)
      .getPropertyValue("--score-text")
      .trim();

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    // Assets
    const bgImage = new Image();
    bgImage.src = "game/background.jpg";

    const deathImage = new Image();
    deathImage.src = "game/you_died_from_hot_clean.png";

    const logoOverlay = new Image();
    logoOverlay.src = "game/laguna-logo.png";

    const loopMusic = new Audio("game/loop.mp3");
    loopMusic.loop = true;
    loopMusic.volume = 0.9;

    const deathSound = new Audio("game/death.wav");
    deathSound.volume = 1;

    // ---------- GAME STATE ----------
    let tileSize = 12; // will be recalculated on resize
    let gameState = "intro"; // intro | playing | dead

    let snake;
    let direction;
    let nextDirection;
    let food;
    let score = 0;
    let lastTick = 0;
    let tickHandle = null;
    let touchStart = null;

    function resetGame() {
      const startX = Math.floor(GRID_COLS / 2);
      const startY = Math.floor(GRID_ROWS / 2) + 6;

      snake = [
        { x: startX - 2, y: startY },
        { x: startX - 1, y: startY },
        { x: startX, y: startY },
        { x: startX + 1, y: startY },
      ];

      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      placeFood();
    }

    function placeFood() {
      while (true) {
        const x = Math.floor(Math.random() * GRID_COLS);
        const y = Math.floor(Math.random() * GRID_ROWS);
        if (!snake.some((s) => s.x === x && s.y === y)) {
          food = { x, y };
          return;
        }
      }
    }

    // ---------- RESIZE ----------
    function resizeCanvas() {
      const displayWidth = canvas.clientWidth;
      if (!displayWidth) return;

      tileSize = Math.floor(displayWidth / GRID_COLS);
      canvas.width = tileSize * GRID_COLS;
      canvas.height = tileSize * GRID_ROWS;

      ctx.imageSmoothingEnabled = false;
      drawFrame(performance.now());
    }

    window.addEventListener("resize", () => {
      // light debounce
      clearTimeout(resizeCanvas._t);
      resizeCanvas._t = setTimeout(resizeCanvas, 80);
    });

    // ---------- INPUT ----------
    window.addEventListener("keydown", (e) => {
      if (e.key === " " || e.code === "Space") {
        if (gameState === "intro") {
          startGame();
        } else if (gameState === "dead") {
          gameState = "playing";
          resetGame();
        }
        return;
      }

      if (gameState === "intro") return;

      switch (e.key) {
        case "ArrowUp":
        case "w":
        case "W":
          if (direction.y === 0) nextDirection = { x: 0, y: -1 };
          break;
        case "ArrowDown":
        case "s":
        case "S":
          if (direction.y === 0) nextDirection = { x: 0, y: 1 };
          break;
        case "ArrowLeft":
        case "a":
        case "A":
          if (direction.x === 0) nextDirection = { x: -1, y: 0 };
          break;
        case "ArrowRight":
        case "d":
        case "D":
          if (direction.x === 0) nextDirection = { x: 1, y: 0 };
          break;
      }
    });

    // Mobile swipe + tap
    canvas.addEventListener(
      "touchstart",
      (e) => {
        if (gameState === "intro") {
          startGame();
        }
        if (e.touches.length === 1) {
          touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      },
      { passive: true }
    );

    canvas.addEventListener(
      "touchend",
      (e) => {
        if (!touchStart) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);

        if (absX < 10 && absY < 10) {
          // treat as tap to pause/restart
          if (gameState === "dead") {
            gameState = "playing";
            resetGame();
          }
          touchStart = null;
          return;
        }

        if (absX > absY) {
          // horizontal
          if (dx > 0 && direction.x === 0) nextDirection = { x: 1, y: 0 };
          if (dx < 0 && direction.x === 0) nextDirection = { x: -1, y: 0 };
        } else {
          // vertical
          if (dy > 0 && direction.y === 0) nextDirection = { x: 0, y: 1 };
          if (dy < 0 && direction.y === 0) nextDirection = { x: 0, y: -1 };
        }
        touchStart = null;
      },
      { passive: true }
    );

    // ---------- MAIN LOOP ----------
    function startGame() {
      gameState = "playing";
      resetGame();
      lastTick = performance.now();
      loopMusic.currentTime = 0;
      loopMusic.play().catch(() => {});
      if (!tickHandle) {
        requestAnimationFrame(gameLoop);
      }
    }

    function gameLoop(timestamp) {
      tickHandle = requestAnimationFrame(gameLoop);
      if (gameState !== "playing") {
        drawFrame(timestamp);
        return;
      }

      if (timestamp - lastTick >= TICK_MS) {
        lastTick = timestamp;
        stepGame();
      }
      drawFrame(timestamp);
    }

    function stepGame() {
      direction = nextDirection;

      const head = snake[snake.length - 1];
      const newHead = { x: head.x + direction.x, y: head.y + direction.y };

      // walls
      if (
        newHead.x < 0 ||
        newHead.x >= GRID_COLS ||
        newHead.y < 0 ||
        newHead.y >= GRID_ROWS
      ) {
        onDeath();
        return;
      }

      // self collision
      if (snake.some((s) => s.x === newHead.x && s.y === newHead.y)) {
        onDeath();
        return;
      }

      snake.push(newHead);

      // food
      if (newHead.x === food.x && newHead.y === food.y) {
        score += 1;
        placeFood();
      } else {
        snake.shift();
      }
    }

    function onDeath() {
      gameState = "dead";
      loopMusic.pause();
      deathSound.currentTime = 0;
      deathSound.play().catch(() => {});
    }

    // ---------- DRAWING ----------
    function clearBoard() {
      ctx.fillStyle = TILE_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawBackgroundImage() {
      if (!bgImage.complete) return;
      const imgRatio = bgImage.width / bgImage.height;
      const canvasRatio = canvas.width / canvas.height;

      let drawWidth, drawHeight;
      if (canvasRatio > imgRatio) {
        drawWidth = canvas.width;
        drawHeight = drawWidth / imgRatio;
      } else {
        drawHeight = canvas.height;
        drawWidth = drawHeight * imgRatio;
      }
      const dx = (canvas.width - drawWidth) / 2;
      const dy = (canvas.height - drawHeight) / 2;

      ctx.drawImage(bgImage, dx, dy, drawWidth, drawHeight);
    }

    function drawSnake() {
      // body
      for (let i = 0; i < snake.length - 1; i++) {
        const seg = snake[i];
        drawTile(seg.x, seg.y, SNAKE_BODY);
      }

      // head
      const head = snake[snake.length - 1];
      drawTile(head.x, head.y, SNAKE_HEAD);

      // eyes on head
      const px = head.x * tileSize;
      const py = head.y * tileSize;
      const eyeSize = Math.max(2, Math.floor(tileSize / 5));

      let leftEye, rightEye;

      if (direction.x === 1) {
        // moving right
        leftEye = { x: px + tileSize - eyeSize * 2 - 1, y: py + eyeSize };
        rightEye = { x: px + tileSize - eyeSize - 1, y: py + eyeSize };
      } else if (direction.x === -1) {
        // left
        leftEye = { x: px + eyeSize, y: py + eyeSize };
        rightEye = { x: px + eyeSize * 2 + 1, y: py + eyeSize };
      } else if (direction.y === -1) {
        // up
        leftEye = { x: px + eyeSize, y: py + eyeSize };
        rightEye = { x: px + tileSize - eyeSize * 2 - 1, y: py + eyeSize };
      } else {
        // down
        leftEye = {
          x: px + eyeSize,
          y: py + tileSize - eyeSize * 2 - 1,
        };
        rightEye = {
          x: px + tileSize - eyeSize * 2 - 1,
          y: py + tileSize - eyeSize * 2 - 1,
        };
      }

      ctx.fillStyle = "#000000";
      ctx.fillRect(leftEye.x, leftEye.y, eyeSize, eyeSize);
      ctx.fillRect(rightEye.x, rightEye.y, eyeSize, eyeSize);
    }

    function drawTile(gridX, gridY, color) {
      const x = gridX * tileSize;
      const y = gridY * tileSize;

      // crisp black outline
      ctx.fillStyle = "#000000";
      ctx.fillRect(x, y, tileSize, tileSize);

      // inner color, inset by 1px
      const inset = Math.max(1, Math.floor(tileSize / 8));
      ctx.fillStyle = color;
      ctx.fillRect(
        x + inset,
        y + inset,
        tileSize - inset * 2,
        tileSize - inset * 2
      );
    }

    function drawFood() {
      drawTile(food.x, food.y, FOOD_COLOR);
    }

    function drawScore() {
      ctx.fillStyle = SCORE_COLOR;
      ctx.font = Math.floor(tileSize * 1) + "px system-ui, sans-serif";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + score, tileSize * 0.4, tileSize * 0.3);
    }

    function drawIntroText() {
      ctx.fillStyle = "#000000";
      ctx.font = Math.floor(tileSize * 0.9) + "px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const cx = canvas.width / 2;
      const cy = canvas.height * 0.78;

      ctx.fillText(
        "Press Space or Arrow key to start",
        cx,
        cy - tileSize * 0.6
      );
      ctx.fillText(
        "On mobile: swipe to move, tap to pause",
        cx,
        cy + tileSize * 0.4
      );
    }

    function drawLogoOverlay() {
      if (!logoOverlay.complete) return;
      const targetWidth = canvas.width * 0.7;
      const ratio = logoOverlay.width / logoOverlay.height;
      const targetHeight = targetWidth / ratio;
      const dx = (canvas.width - targetWidth) / 2;
      const dy = canvas.height * 0.16;
      ctx.drawImage(logoOverlay, dx, dy, targetWidth, targetHeight);
    }

    function drawDeathOverlay() {
      if (!deathImage.complete) return;
      const targetHeight = canvas.height * 0.42;
      const ratio = deathImage.width / deathImage.height;
      const targetWidth = targetHeight * ratio;
      const dx = (canvas.width - targetWidth) / 2;
      const dy = (canvas.height - targetHeight) / 2 - tileSize * 0.6;
      ctx.drawImage(deathImage, dx, dy, targetWidth, targetHeight);

      ctx.fillStyle = "#000000";
      ctx.font = Math.floor(tileSize * 1) + "px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("Press Space to retry", canvas.width / 2, dy + targetHeight + tileSize * 0.4);
    }

    function drawFrame(timestamp) {
      clearBoard();
      drawBackgroundImage();

      if (gameState === "intro") {
        if (!snake) resetGame();
        drawSnake();
        drawFood();
        drawScore();
        drawLogoOverlay();
        drawIntroText();
      } else if (gameState === "playing") {
        drawSnake();
        drawFood();
        drawScore();
      } else if (gameState === "dead") {
        drawSnake();
        drawFood();
        drawScore();
        drawDeathOverlay();
      }
    }

    // Pause music when tab hidden
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        loopMusic.pause();
      } else if (gameState === "playing") {
        loopMusic.play().catch(() => {});
      }
    });

    // ---------- INIT ----------
    window.addEventListener("load", () => {
      resizeCanvas();
      resetGame();
      drawFrame(performance.now());
      requestAnimationFrame(gameLoop);
    });
  </script>
</body>
</html>
